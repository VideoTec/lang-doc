#include <stdio.h>
FILE *fopen(const char *fname, const char *mode);

fopen()
函数打开由fname(文件名)指定的文件, 并返回一个关联该文件的流.
如果发生错误, fopen()返回NULL.
mode(方式)是用于决定文件的用途(例如 用于输入,输出,等等)

------------------------------
流式文件 设备文件
------------------------------
文件描述符是linux下的一个概念,linux下的一切设备都是以文件的形式操作.
如：网络套接字、硬件设备等、当然包括操作文件。

设备文件不可以当成流式文件来用，只能用open

------------------------------
文件描述符 文件指针
------------------------------

文件描述符 - 文件句柄 - File descriptor
文件指针   - 指向文件结构的指针 - FILE结构体的指针

open  是系统调用 返回的是文件句柄，文件的句柄是文件在文件描述副表里的索引
fopen 是C的库函数，返回的是一个指向文件结构的指针

文件描述符是linux下的一个概念,linux下的一切设备都是以文件的形式操作.
如：网络套接字、硬件设备等、当然包括操作文件。
因此，文件描述符为在该系列平台上进行设备相关的编程实际上提供了一个统一的方法

UNIX/Linux平台上的 FILE结构体 的实现中往往都是封装了文件描述符变量在其中

Windows 下的文件描述符和信号量、互斥锁等内核对象一样都记作 HANDLE。

文件描述符在形式上是一个非负整数。
实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。
当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符

控制台(Console)的标准输入，标准输出，标准错误输出也对应了三个文件描述符。它们分别是0,1,2。
在实际编程中，如果要操作这三个文件描述符时，建议使用<unistd.h>头文件中定义的三个宏来表示: 
STDIN_FILENO, STDOUT_FILENO以及STDERR_FILENO

------------------------------
缓冲文件系统 非缓冲文件系统
------------------------------

非缓冲文件系统
-----------------------------------------
1. 对应的操作
open, close, read, write, getc, getchar, putc, putchar
读写字符、字符串、格式化数据，也可以读写二进制数 据

2. 返回一个文件描述符(用户程序区的)
3. ANSI标准不再包括非缓冲文件系统
4. 系统级的输入输出，它不设文件结构体指针，只能读写二进制文件，但效率高、速度 快

缓冲文件系统
-----------------------------------------
1. 对应的操作
fopen, fclose, fread, fwrite, fgetc, fgets, fputc, fputs, freopen, fseek, ftell, rewind

2. 返回一个文件指针 一个指向文件结构的指针
3. 缓冲区 的作用
执行读文件的操作时，从磁盘文件将数据先读入内存“缓冲区”， 装满后再从内存“缓冲区”依此读入接收的变量
执行写文件的操作时，先将数据写入内存“缓冲区”，待内存“缓冲区”装满后再写入文件
内存 “缓冲区”的大小，影响着实际操作外存的次数，
内存“缓冲区”越大，则操作外存的次数就少，执行速度就快、效率高。
一般来说，文件“缓冲区”的大小随机器 而定

4. 因为有缓冲区，所以产生了 fflush 函数。
5. fopen是ANSIC标准中的C语言库函数，在不同的系统中应该调用不同的内核api

------------------------------------------------
open 和 fopen 的取舍
------------------------------------------------
如果顺序访问文件，fopen系列的函数要比直接调用open系列快；
如果随机访问文件open要比fopen快

原因：
fopen和open最主要的区别是fopen在用户态下就有了缓存，在进行read和write的时候减少了用户态和内核态的切换
open则每次都需要进行内核态和用户态的切换
